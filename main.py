import numpy as np
import math as m
import random
import array as arr
import gurobipy as gp
from gurobipy import GRB

n =50  # total number of nodes
maxIter = 1
V = [i for i in range(0, n)]  # all nodes (including the base station)
W = [j for j in range(1, n)]  # all sensor nodes
A = [(i, j) for i in W for j in V if i != j]  # links

xcoor = []
ycoor = []

# PARAMETERS
epsilon = 10 ** -10
rho = (5 * (10 ** -8))
alpha = 4
energy = 10
Prx = (5 * (10 ** -8))
Rnet = 100
BigM = 1e10
Lout = 7
maxIter=10
# print(Prx)

BYTE = 1
S = {i: BYTE for i in W}  # the amount of data generated by each node

e = {i: energy for i in W}  # Initial battery energy of nodes

file = open("results.txt", "w")
file.truncate(0)

iterNo=1
while iterNo <= maxIter:
    random.seed(iterNo)

    # Create a disc-shaped topology
    for i in V:
        if i == 0:
            xcoor.append(0)
            ycoor.append(0)
        else:
            angle = 2 * m.pi * random.random()
            r = Rnet*m.sqrt(random.random())
            x = r * m.cos(angle)
            y = r * m.sin(angle)
            xcoor.insert(i , x)
            ycoor.insert(i , y)

    # Calculate the distance between node-i and node-j
    D = {(i, j): m.sqrt((xcoor[i] - xcoor[j]) ** 2 + (ycoor[i] - ycoor[j]) ** 2) for i in V for j in V}
    # Calculate the transmission power between node-i and node-j
    P = {(i, j): (rho + epsilon * D[i, j] ** alpha) for i, j in A}
    Ptx = {(i, j): (P[i, j]) for i, j in A}

    BYTE = 1
    S = {i: BYTE for i in W}  # the amount of data generated by each node
    e = {i: energy for i in W}

    ####################################
    # OPTIMIZATION MODEL (USING GUROBI)
    ####################################

    # Create a Model instance
    mdl = gp.Model("Model")
    # mdl.setParam('MemLimit', 24)
    #  Suppresses all console output from Gurobi.
    mdl.Params.LogToConsole = 0
    #  Suppresses all console output from Gurobi.
    mdl.setParam('OutputFlag', 0)


    # Flow Variable (Continuous)
    f = {(i, j): mdl.addVar(vtype=GRB.CONTINUOUS, name="f_{0}_{1}".format(i, j)) for i, j in A}
    a = {(i, j): mdl.addVar(vtype=GRB.BINARY, name="a_{0}_{1}".format(i, j)) for i, j in A}
    T = mdl.addVar(vtype=GRB.CONTINUOUS, name="T")

    for i in W:
        mdl.addConstr(gp.quicksum(f[i, j] for j in V if i != j) - (gp.quicksum(f[j, i] for j in W if i != j)) == S[i] * T, name="flowBalance")
    for i in W:
        mdl.addConstr((gp.quicksum(Ptx[i, j] * f[i, j] for j in V if i != j) + Prx * gp.quicksum(f[j, i] for j in W if i != j)) <= e[i], name="energyBalance")
    for (i,j) in A:
        mdl.addConstr(f[i, j] <= BigM * a[i,j], name="capacityFlow")
    for i in W:
        mdl.addConstr(gp.quicksum(a[i, j] for j in V if i != j) <= Lout, name="outLink")
    
    # Maximization/Minimization
    mdl.ModelSense = gp.GRB.MAXIMIZE

    # Set the Objective Function
    objective = T
    mdl.setObjective(objective)

    # Solve the model
    mdl.optimize()

    # Write the model in "mdl.lp" file
    # mdlName = "mdl%d.lp" % ii
    # mdl.write(mdlName)

    # Get the optimal solution as object
    obj = mdl.getObjective()

    # Lifetime Value
    LT = obj.getValue()

    # Solution Time
    ST = mdl.Runtime

    # This prints the non-zero solutions found
    mdl.printAttr('X')
    print('Iter=', iterNo, '-> Lifetime=', round(LT), 'seconds and Solution Time=', round(ST, 3), 'sec.')

    # Write results to a text file
    file.write("{}; {:.2f}; {:.2f} \n".format(iterNo, LT, 1000*ST))

    # Post-Processing
    f_val = np.zeros((n, n))
    wgtDist = np.zeros((n, n))

    if mdl.status == GRB.Status.OPTIMAL:
        # Get the optimal solution of the flow variable - f
        flowSol = mdl.getAttr('x', f)
        for i, j in A:
            if flowSol[i, j] > 0:
                f_val[i, j] = flowSol[i, j]
                wgtDist[i,j] = flowSol[i,j]*D[i,j]
                #print('%s -> %s: %g flow' % (i, j, flowSol[i,j]))
                #print('%s -> %s: %g meters' % (i, j, wgtDist[i, j]))

        # Average distance between source and sink node
        numer = sum(sum(wgtDist))/sum(sum(f_val))

    iterNo += 1

file.close()